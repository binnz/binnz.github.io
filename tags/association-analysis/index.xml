<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Association-Analysis on California Dreaming</title>
    <link>https://binnz.github.io/tags/association-analysis/</link>
    <description>Recent content in Association-Analysis on California Dreaming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 25 Mar 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://binnz.github.io/tags/association-analysis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Association Rule Mining 的 Java 程式實作</title>
      <link>https://binnz.github.io/post/2018-03-25-association-implementation/</link>
      <pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://binnz.github.io/post/2018-03-25-association-implementation/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://chih-ling-hsu.github.io/2017/03/25/Data-Mining-Association-Analysis&#34;&gt;關聯規則探勘(Association Rule Mining)&lt;/a&gt;是資料探勘領域中很常用的一種探勘方式，其中&lt;code&gt;Apriori&lt;/code&gt;演算法和&lt;code&gt;FP-Growth&lt;/code&gt;演算法是最為有名的。在這篇文章中，我會介紹我在這兩個演算法上的實作以及實作成果的實驗數據。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mining Association Rules on New York City Bike Dataset</title>
      <link>https://binnz.github.io/post/2018-01-01-association-rule-mining/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://binnz.github.io/post/2018-01-01-association-rule-mining/</guid>
      <description>&lt;p&gt;What   we   want   to   do here   is  to design 3 mining tasks with their definitions of transactions and   find   some   rules   behind them.&lt;/p&gt;
&lt;p&gt;For   each   task,   we   should&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Try &lt;strong&gt;at   least   two   discretization   methods&lt;/strong&gt; (divided   by 10, divided   by   20, &amp;hellip;)&lt;/li&gt;
&lt;li&gt;Try &lt;strong&gt;at   least two   algorithms&lt;/strong&gt; (Apriori, FP-growth, &amp;hellip;) to   find   association   rules.&lt;/li&gt;
&lt;li&gt;List the interesting  rules.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compare&lt;/strong&gt;   the   differences   between   them.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Association Analysis of Sequence Data</title>
      <link>https://binnz.github.io/post/2017-07-01-sequence-data/</link>
      <pubDate>Sat, 01 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://binnz.github.io/post/2017-07-01-sequence-data/</guid>
      <description>&lt;p&gt;A sequence is an ordered list of elements (transactions).   For example, purchase history of a given customer, history of events generated by a given sensor, browsing activity of a particular Web visitor, and so on.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ozzU8p0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;A sequence $s$ is defined as&lt;/p&gt;
&lt;p&gt;$$
s = &amp;lt;e_1~e_2~e_3~&amp;hellip;&amp;gt;
$$&lt;/p&gt;
&lt;p&gt;Where $e_i$ is the $i^{th}$ element, containing a collection of events (items) and attributed to a specific time or location.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Data Mining - Preprocessing for Association Analysis</title>
      <link>https://binnz.github.io/post/2017-07-01-preprocessing-association-analysis/</link>
      <pubDate>Sat, 01 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://binnz.github.io/post/2017-07-01-preprocessing-association-analysis/</guid>
      <description>&lt;p&gt;Before we do association analysis, we need to handle the following 2 issues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Categorical Attributes&lt;/li&gt;
&lt;li&gt;Continuous Attributes&lt;/li&gt;
&lt;li&gt;Multi-Level Concept Hierarchy&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Handling Continuous Attributes with Discretization-based Methods</title>
      <link>https://binnz.github.io/post/2017-07-01-handling-continuous-attributes/</link>
      <pubDate>Sat, 01 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://binnz.github.io/post/2017-07-01-handling-continuous-attributes/</guid>
      <description>&lt;p&gt;Size of the discretized intervals affect support &amp;amp; confidence.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If intervals too small
&lt;ul&gt;
&lt;li&gt;may not have enough support&lt;/li&gt;
&lt;li&gt;e.g. {Refund = No, (Income = 51,250)} $\rightarrow$ {Cheat = No}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If intervals too large
&lt;ul&gt;
&lt;li&gt;may not have enough confidence&lt;/li&gt;
&lt;li&gt;e.g. {Refund = No, (0K $\leq$ Income $\leq$ 1B)} $\rightarrow$ {Cheat = No}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When there is any numerical attribute, the problem is to discretize individual numerical attribute into interesting intervals.   Each interval is represented as a Boolean attribute.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Data Mining - Association Analysis</title>
      <link>https://binnz.github.io/post/2017-03-25-data-mining-association-analysis/</link>
      <pubDate>Sat, 25 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://binnz.github.io/post/2017-03-25-data-mining-association-analysis/</guid>
      <description>&lt;p&gt;Association analysis is useful for discovering interesting relationships hidden in large data sets.   The uncovered relationships can be represented in the form of &lt;strong&gt;association rules&lt;/strong&gt; or sets of frequent items.&lt;/p&gt;
&lt;p&gt;For example, given a table of market basket transactions&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;TID&lt;/th&gt;
&lt;th&gt;Items&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;{Bread, Milk}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;{Bread, Diapers, Beer, Eggs}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;{Milk, Diapers, Beer, Cola}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;{Bread, Milk, Diapers, Beer}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;{Bread, Milk, Diapers, Cola}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The follwing rule can be extracted from the table:&lt;/p&gt;
&lt;p&gt;$$
{Milk, Diaper} \rightarrow {Beer}
$$&lt;/p&gt;
&lt;p&gt;A common strategy adopted by many association rule mining algorithms is to decompose the problem into 2 major subtasks:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Frequent Itemset Generation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Find all the itemsets that satisfy the &lt;em&gt;minsup&lt;/em&gt; threshold.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Rule Generation&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Frequent Itemset Generation Using Apriori Algorithm</title>
      <link>https://binnz.github.io/post/2017-03-25-apriori/</link>
      <pubDate>Sat, 25 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://binnz.github.io/post/2017-03-25-apriori/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The Apriori Principle&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;If an itemset is frequent, then all of its subsets must also be frequent.
Conversely, if an subset is infrequent, then all of its supersets must be infrequent, too.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The key idea of the Apriori Principle is monotonicity. By the &lt;strong&gt;anti-monotone&lt;/strong&gt; property of support, we can perform &lt;strong&gt;support-based pruning&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;$$
\forall X,Y: (X \subset Y) \rightarrow s(X) \geq s(Y)
$$&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Frequent Itemset Generation Using FP-Growth</title>
      <link>https://binnz.github.io/post/2017-03-25-frequent-itemset-generation-using-fp-growth/</link>
      <pubDate>Sat, 25 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://binnz.github.io/post/2017-03-25-frequent-itemset-generation-using-fp-growth/</guid>
      <description>&lt;p&gt;FP-Growth uses FP-tree (Frequent Pattern Tree), a compressed representation of the database.   Once an FP-tree has been constructed, it uses a recursive divide-and-conquer approach to mine the frequent itemsets.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Generate a Candidate Hash Tree</title>
      <link>https://binnz.github.io/post/2017-03-25-generate-a-candidate-hash-tree/</link>
      <pubDate>Sat, 25 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://binnz.github.io/post/2017-03-25-generate-a-candidate-hash-tree/</guid>
      <description>&lt;p&gt;To generate a candidate hash tree, the followings are required.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hash function&lt;/li&gt;
&lt;li&gt;Max leaf size - if number of candidate itemsets exceeds max leaf size, split the node&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
